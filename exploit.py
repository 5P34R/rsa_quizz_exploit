import gmpy2
from Crypto.Util.number import *
from factordb.factordb import FactorDB
from pwn import *
from pydantic import ValidationError


class RSA_QUIZZ_SOLVER:
    
    def __init__(self, host, port) -> None:
        self.host = host
        self.port = port
        self.io =  remote(host,port)
        self.io.recvline_endswith(b"here!")
        
    def qn_filter(self, qn):
        qn = qn.decode().splitlines()
        giv_indx = qn.index("#### NEW PROBLEM ####")
        finding_indx = qn.index("##### PRODUCE THE FOLLOWING ####")
        given_list =  qn[giv_indx+1:finding_indx]
  
        self.given_list = given_list
        find_list = qn[finding_indx + 1:len(qn) -1]
        self.find_list = find_list

        if len(given_list)  > 0 and len(find_list) > 0:
            
            return given_list, find_list
        else:
            log.info(f"[-] Given Values: {given_list}")
            log.info(f"[-] Value need to finded: {find_list}")
            raise ValidationError("the lists are empty")
        
    def send(self, value ,is_ok):
        if is_ok:
            self.io.sendline(b"Y")
            self.io.recvuntil(b"#### TIME TO SHOW ME WHAT YOU GOT! ###")
            log.info(self.io.recv())
            self.io.sendline(str(value).encode())
            
            res = self.io.recvuntil(b"Outstanding move!!!")
            if res == None:
                log.info(self.io.recv())

        else:
            self.io.sendline(b"N")
            log.info(self.io.recv())
        
    def solve(self):
        rsa_dict = {"p":0, "q":0, "n":0, "e":0, "ciphertext":0, "totient":0, "plaintext": 0}
        # if data:
        try:
            qn = self.io.recvuntil(b"IS THIS POSSIBLE and FEASIBLE? (Y/N):") 
        except EOFError as e:
            log.info(self.io.recv())
            exit()
        
        gvn, find = self.qn_filter(qn)
        print(gvn, find)
        for i in range(len(gvn)):
            label = gvn[i].split(":")[0].strip()
            value = int(gvn[i].split(":")[1].strip())
            rsa_dict[label] = value
        
        # print(rsa_dict)
        if find[0] == "n" and not rsa_dict["p"] == 0 and not rsa_dict["q"] == 0:
            n = rsa_dict["p"] * rsa_dict["q"]
            self.send(n, True)
        elif find[0] == "q" and not rsa_dict["p"] == 0 and not rsa_dict["n"] == 0:
            q = rsa_dict["n"] // rsa_dict["p"]
            self.send(q, True)
        
        elif find[0] == "q" and find[1] == "p" and rsa_dict["n"] > 0:
            # f = FactorDB(int(rsa_dict["n"]))
            # # breakpoint()
            # if "200" in str(f.connect().status_code):
            #     if f.get_status() == "C":
            #         print("[+] Unable to factorize given N")
            self.send(..., False)
            # else:
            #     print("[-] Something wrong with factordb")    
        
        elif find[0] == "totient(n)" and rsa_dict["p"] > 0 and rsa_dict["q"] > 0:
            phi = (rsa_dict["p"] - 1)*(rsa_dict["q"] - 1)
            self.send(phi, True)
            
        elif find[0] == "plaintext" and rsa_dict["n"] > 0 and rsa_dict["e"] > 0 and rsa_dict["ciphertext"] > 0:
            if len(str(rsa_dict["ciphertext"])) < len(str(rsa_dict["n"])):
                val, ok = gmpy2.iroot(rsa_dict["ciphertext"], rsa_dict["e"])
                
                if ok:
                    self.send(val, True)
                else:
                    log.info("[-] Unable to find the cuberoot")
                    self.send(..., False)
            else:
                if rsa_dict["p"] > 0:
                    rsa_dict["q"] =rsa_dict["n"] // rsa_dict["p"]
                    phi = (int(rsa_dict["p"]) - 1) * (int(rsa_dict["q"]) -1)
                    d = pow(int(rsa_dict["e"]), -1, phi)
                    m = pow(int(rsa_dict["ciphertext"]), d, rsa_dict["n"])
                    log.info(b"Found the flag : "+long_to_bytes(m))
                    self.send(m, True)
        elif find[0] == "ciphertext" and rsa_dict["plaintext"] >0 and rsa_dict["n"] >0 and rsa_dict["e"] > 0:
            res = pow(rsa_dict["plaintext"], rsa_dict["e"], rsa_dict["n"])
            self.send(res, True)
         
        elif find[0] == "d" and rsa_dict["p"] > 0 and rsa_dict["q"] > 0 and rsa_dict["e"] > 0:
            d = pow(rsa_dict["e"], -1, (rsa_dict["p"] - 1) * (rsa_dict["q"] - 1))
            if not d ==0:
                self.send(d, True) 
        else:
            log.info("not able to solve... try manually")
            exit()
        return 1
    
rsa = RSA_QUIZZ_SOLVER("jupiter.challenges.picoctf.org", 58617)
c = 0
while c <= 100:
    c += rsa.solve()
    